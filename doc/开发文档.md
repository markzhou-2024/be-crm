美容行业顾问端小程序开发文档
1. 页面路径规划（pages/xxx）
根据功能模块，将小程序划分为以下页面（使用 Vue3 + uni-app + uniCloud 实现）。页面路径以 pages/ 开头，后跟模块名称和页面功能：
首页（数据汇总）：pages/home/index – 显示概览数据和快捷入口。
门店列表页：pages/stores/index – 顾问负责的门店列表（若顾问仅有一个门店，可直接跳转门店详情）。
门店详情页：pages/stores/detail – 展示单个门店信息，支持编辑基本资料（如名称、地址等）。
客户列表页：pages/customers/index – 客户管理主页面，列出所负责客户，可按类别筛选、搜索。
客户编辑页：pages/customers/edit – 新增/编辑客户信息表单页。
客户详情页：pages/customers/detail – 客户详情及关系管理，包括购买的套餐、消耗记录、预约记录等 tab 切换。
套餐（产品）列表页：pages/products/index – 服务项目/套餐列表页，展示可供销售或管理的美容服务包（产品）信息。
套餐新增页：pages/packages/add – 给客户新增购买套餐（选择产品类型、设置参数）。
消耗记录新增页：pages/usages/add – 新增一次套餐内消耗记录（选择套餐、填写消耗详情）。
预约新增页：pages/appointments/add – 新建客户预约记录（选择日期时间、项目等）。
报表页：pages/reports/index – 数据报表和统计分析页面（更详细的数据展示，如业绩、预约量等）。
**说明：**底部 TabBar 固定包括：首页、门店、客户、产品、报表五个主入口，分别对应以上主要页面。用户通过微信授权登录后，默认进入“首页”数据汇总页。
2. 每页组件结构
各页面采用模块化组件划分，保证代码清晰，可读性高。按照页面功能，我们将UI拆分为若干区块（block），下面逐页说明组件结构：
首页（数据汇总页）：顶部是欢迎栏（显示顾问姓名及问候语），下方是数据概览板块，包括：
「指标卡片组件」：显示关键指标汇总（如负责门店数、总客户数、总销售额、累计消耗次数等），卡片设计简洁圆角，背景浅色。
「快捷导航网格」：数个图标按钮入口（例如“新增客户”、“今日预约”、“新增销售”等），方便顾问快速操作常用功能。
最近动态列表（可选）：下方列出最近的关键动态摘要，如最新新增的客户、最近预约提醒等。每项使用列表项组件展示简短信息，点击可跳转相应详情。
门店列表页：包含：
页头：标题“我的门店”及（若支持）“新增门店”按钮。
门店卡片列表：使用门店卡片组件显示每个门店的摘要信息（门店名称、地址、电话等）。卡片为圆角矩形，浅色背景，卡片内部可能包含门店Logo或首字母头像。点击卡片进入门店详情页。
如果顾问只有一个门店，可省略列表，直接显示该门店详情。
门店详情页：分为上下两个区块：
门店信息块：显示门店详细资料，如门店名称、地址、联系方式等，可使用只读表单样式呈现，并提供“编辑”按钮切换到编辑模式或跳转编辑页。
统计概览块：展示与该门店相关的数据统计（如该店客户数量、总销售额、近期预约情况）。也可包含关联客户列表的入口或简要列表（列出该店近期互动的客户，点击跳转客户详情）。
客户列表页（客户管理主页面）：顶部包含筛选和搜索区域，下方是客户列表：
顶部导航栏：标题“客户管理”。右上角放置“新增客户”按钮（使用「+」号图标表示）。
筛选栏：使用分段选择控件或标签组件提供筛选选项（如“全部客户 / VIP客户 / 活跃客户”三个标签）。当前选中标签高亮显示（金色底或主题色底），非选中标签浅色底。筛选切换时刷新列表。
搜索框：圆角矩形搜索输入框，左侧有放大镜图标，提示文字“搜索客户”，支持按姓名/电话查询。搜索框组件采用浅灰色背景和圆角，符合苹果风格。
客户列表：采用客户列表项组件垂直排列显示客户概要信息（头像、姓名、标签、最后到店时间、累计消费等）。每项呈卡片式：白色背景，略有圆角和阴影/边框，用留白将各项分隔。示例：头像+姓名（如“张小姐”）在左，右侧有箭头指示可进入详情；姓名旁如有“VIP”标签（小圆角标签，突出显示）；下一行小字显示“上次到店：X天前”，以及“累计消费：¥YY”。点击任意客户项跳转客户详情页
zcool.com.cn
。
客户列表页示例：顶部筛选和搜索栏，列表项展示头像、姓名、标签及最近到店和消费信息。
客户编辑页（新增/编辑客户）：使用表单组件集合输入客户资料：
表单字段：包括姓名（必填，文本）、性别（单选，如男/女）、联系电话（数字）、生日（日期选择器，可选）、所属门店（下拉选择，若顾问管理多个门店则需要选择）。可选字段：标签/等级（如是否VIP，下拉或开关）、备注。每个字段对应表单控件组件，排列使用统一的间距和对齐。
提交按钮：页面底部固定“保存”按钮，点击后校验输入并调用云函数提交。
交互：保存成功后navigateBack返回上一页（客户列表或详情），并刷新列表数据。若是编辑，页面在进入时会根据传入的客户ID初始化表单值。
客户详情页：采用Tab切换展示该客户的不同信息分类，顶部还包含客户基本信息：
客户信息头部：包含头像、姓名、联系方式简要。可在此显示客户等级标签（如VIP）以及累计消费总额、累计到店次数等关键数据，以概览形式呈现。该信息块风格类似名片，背景用浅色或淡淡渐变，四角圆润。 客户详情页示例：顶部为客户基本信息卡片，显示姓名、标签、联系方式及统计数据，下面是可左右滑动的标签栏用于切换购买/消耗/预约等信息。
Tab 标签栏：紧接信息头部，是横向可滑动的选项卡组件，包含诸如“购买”“消耗”“预约”（及可能的“图片”“备注”等）标签页。当前选中标签以主题色高亮底纹，下方有细横条指示当前所在页。每个标签页对应下方一个子列表板块。
购买 tab：显示该客户购买过的套餐列表。使用套餐卡片组件列出每个服务包名称、购买日期、所在门店、金额、包含次数等信息。如果套餐有次数/余额，还可显示剩余可用次数。列表项右侧可提供操作菜单（如编辑或退订）。
消耗 tab：显示该客户的消耗记录列表（消费日志）。每条记录包含消耗日期、使用的套餐名称/项目、消耗量（次数或金额）等。按时间倒序排列。
预约 tab：显示预约记录列表，每条包含预约日期时间、预约项目/套餐、状态（已完成/待服务/已取消）等。将即将到期或未完成的预约高亮标注。
（若设计包含“图片”和“备注”tab，可分别用于存储客户治疗前后照片及顾问针对客户的私人备注说明，但这些属于扩展功能，此处主要关注购买/消耗/预约三项核心。）
快捷操作按钮：在客户详情页底部，提供三个主操作按钮用于快速增加记录：“+购买”、“+消耗”、“+预约”。这三个按钮采用醒目的样式（如悬浮按钮或固定在底的宽按钮），颜色使用主题色系且带圆角。例如每个按钮一个圆角矩形，内含 “＋” 图标和文字说明。点击分别跳转到相应的新增页（套餐新增、消耗新增、预约新增）。为了方便操作，这些按钮在任何Tab下均可见，或根据当前Tab智能调整默认选项。
套餐（产品）列表页：展示美容服务产品/套餐的清单：
产品列表：使用产品卡片组件显示每种服务套餐的详情，包括套餐名称、简介说明、价格、疗程次数/有效期等。卡片风格统一（白底圆角，带简洁阴影或边框）。可能按类别或项目类型分组显示。
查看/选择：顾问点击某产品卡，可查看详细介绍（可弹出对话框或新页面）。在新增套餐给客户时，此页也可作为选择器使用：选择一个套餐后进入购买确认流程。
注：由于没有后台管理支持，产品列表可由开发预置或从云数据库读取（由管理员预先配置）。顾问端通常不新增或删除产品，只能查看已有产品包信息。
套餐新增页（给客户购买套餐）：提供给顾问为客户新增购买服务的界面：
选择套餐：如果已有标准产品列表，首先选择套餐类型（可弹出产品列表供选择，或下拉选择已有产品名称）。选择后展示该套餐的固定信息（价格、总次数等），若需顾问输入购买细节（如优惠价、购买日期），则提供相应输入框。
输入有效期/备注：可选输入此次购买的备注或特殊约定，如有效期限、自定义项等。
确认购买按钮：点击提交调用package_create云函数，将购买记录写入数据库（关联客户ID、套餐ID等），成功后返回客户详情页并刷新“购买”列表。
消耗记录新增页：用于登记一次消费/疗程消耗：
选择套餐：下拉或弹出选择此客户要消耗的套餐（列出该客户所有在用套餐）。顾问选择后，其套餐剩余次数等信息可显示提醒。
消耗详情：输入本次消耗的数量（默认为1次，可根据项目不同调整）、日期（默认为当天，可修改），以及备注（如哪位美容师执行的，或消耗说明）。
提交按钮：确认后调用usage_create云函数，将记录保存，并更新套餐剩余次数等。成功后返回客户详情并刷新“消耗”列表，同时在“购买”列表中更新对应套餐的已用/剩余次数。
预约新增页：让顾问为客户添加预约：
预约项目：选择预约的服务项目或套餐。如果针对已有套餐服务，选择对应套餐或项目名称；也可独立于套餐预约（如免费的皮肤检测等），则选择项目类别。
日期时间选择：调用日期选择器和时间选择器组件，选取预约日期和具体时间段。确保避免已占用的时段冲突（可选功能：简单检查提醒）。
额外信息：输入预约地点（若顾问有多个门店，需要选择哪家门店服务）、备注说明（可记录客户特殊要求）。
提交按钮：保存后调用appointment_create云函数，将预约写入数据库（状态默认为待服务）。成功返回后刷新客户详情“预约”列表，并在报表页或其他提醒模块中增加该预约提醒。
报表页：提供业务数据的可视化报表：
筛选控制：如日期范围选择、门店筛选（若需要分店查看）等控件，默认显示近期（本月）数据。
关键指标：在页首以指标卡片方式列出关键数据（如本月新增客户数、本月销售额、本月完成预约数等），直观醒目。
图表组件：使用柱状图、折线图等展示一段时间内的趋势（如客户增长、营业额走势、预约完成率等）。图表可采用第三方图表库（如 uCharts）集成在小程序中。
数据列表：下方以列表或表格形式展示详细数据，如按门店/项目分类的业绩列表、排行榜等。
报表页注重清晰简洁，每个图表或数据块有明确标题说明。用户可直观了解业务健康状态。
3. 数据结构
系统涉及主要业务数据实体包括：门店(Store)、客户(Customer)、套餐(Package)、消耗记录(Usage)、预约(Appointment)。下面定义各数据结构的字段和说明（使用 JSON 风格描述字段）：
门店 Store：代表美容店铺或分店信息。
Store = {
  _id: String,       // 门店ID，主键
  name: String,      // 门店名称
  address: String,   // 地址（详细地址或描述）
  phone: String,     // 联系电话
  consultant_id: String, // 顾问用户ID（关联User，以限定只允许该顾问查看管理）
  // （可选）其他信息：如营业时间、店铺Logo图片URL等
  created_at: Date,  // 创建时间
  updated_at: Date   // 更新时间
}
说明：顾问只能管理自己负责的门店，因此每个门店记录关联一个顾问ID。没有后台角色情况下，门店数据可在数据库预先导入或由顾问添加但只能查看/编辑自己的。
客户 Customer：顾问所管理的客户信息。
Customer = {
  _id: String,        // 客户ID
  name: String,       // 客户姓名
  gender: String,     // 性别 ("male"/"female"，或存 "M"/"F")
  phone: String,      // 联系电话
  birth_date: Date,   // 出生日期（生日）
  store_id: String,   // 所属门店ID（顾问可能管理多个门店时需要）
  vip: Boolean,       // 是否VIP客户
  last_visit: Date,   // 上次到店日期（用于判定活跃/沉睡）
  total_spent: Number,// 累计消费金额（可由套餐购买和消耗记录计算更新）
  visit_count: Number,// 累计到店次数（可由消耗或预约完成记录统计）
  created_at: Date,
  updated_at: Date
}
说明：可根据业务需要增加字段，例如备注 notes、头像 avatar 等。last_visit和total_spent等字段有助于在列表快速筛选和显示，但也可在需要时通过数据库聚合计算。vip用于标记VIP客户，方便筛选。“活跃客户”的判定可根据 last_visit 距今时间或 visit_count 阈值在前端/后端计算。
套餐 Package：客户购买的服务套餐或项目记录。每条记录代表某客户购买了一项服务或疗程套餐。
Package = {
  _id: String,         // 套餐记录ID
  customer_id: String, // 关联客户ID
  product_name: String,// 套餐名称（例如“面部护理A套餐”）
  product_id: String,  // 套餐类别ID（如果有预定义产品列表，则存其ID，没有则可缺省）
  purchase_date: Date, // 购买日期
  price: Number,       // 购买金额
  total_sessions: Number,   // 总次数/总额度（如购买疗程次数，如不限次则可为空或Infinity）
  used_sessions: Number,    // 已使用次数
  remaining_sessions: Number,// 剩余次数（可实时计算或每次消耗更新）
  expire_date: Date,   // 到期日期（如有有效期限制）
  note: String,        // 备注（如特殊说明）
  store_id: String,    // 关联门店（在哪个店购买/适用）
  created_at: Date,
  updated_at: Date
}
说明：套餐记录体现“客户购买了什么服务项目”。如有标准产品清单，可通过 product_id 参考产品表获取名称和默认总次数等。used_sessions和remaining_sessions用于追踪消耗进度，每次新增Usage应更新这些字段。对于不限次数或按金额的套餐，可调整字段含义或增设例如 total_amount/used_amount。
消耗记录 Usage：客户每次使用/消耗套餐服务的记录。
Usage = {
  _id: String,         // 消耗记录ID
  customer_id: String, // 所属客户ID（方便按客户聚合查询）
  package_id: String,  // 所属套餐ID（明确对应消耗的是哪个套餐）
  usage_date: Date,    // 消耗发生日期
  amount: Number,      // 消耗数量（一次/次数，缺省为1，可表示本次用了1次疗程）
  item: String,        // 消耗项目描述（例如使用了哪个具体服务项目，可选）
  operator: String,    // 操作人员名（哪个美容师服务的，可选记录）
  note: String,        // 备注说明
  created_at: Date
}
说明：添加消耗记录时，通过 package_id 找到对应套餐，扣减其剩余次数。一个Usage往往对应消耗套餐的一次服务。系统可根据Usage累计计算客户的last_visit（取最新的usage_date）和visit_count等。customer_id存储是为了方便按客户ID查询所有消费记录（用于详情“消耗”tab）。
预约 Appointment：客户预约到店服务的记录。
Appointment = {
  _id: String,          // 预约ID
  customer_id: String,  // 关联客户ID
  store_id: String,     // 预约门店ID（顾问负责的哪个门店举办服务）
  appointment_time: Date,// 预约日期时间
  service_item: String, // 预约项目名称（可以是具体服务，或套餐名称）
  package_id: String,   // 关联套餐ID（如果此次预约是用某套餐的一次服务，则可选填）
  status: String,       // 状态 ("pending"待服务/"completed"已完成/"cancelled"已取消等)
  note: String,         // 备注（如特殊要求）
  created_at: Date,
  updated_at: Date
}
说明：预约记录主要字段是日期时间和项目。status字段用于区分预约是否完成或取消。完成后可由顾问手动更新状态，或者通过消费记录自动触发。若提供消息通知，可根据预约时间提前提醒顾问或客户。
此外，还有用户 User数据结构用于存储顾问的账号信息（包含微信授权的 openid、昵称等）。由于本小程序仅顾问角色使用，用户表结构简单，可直接采用 uni-id 提供的用户体系或自定义：
User = {
  _id: String,       // 用户ID（uni-id下为自动生成）
  role: String,      // 角色标识，例如 "consultant"
  name: String,      // 顾问姓名（可从微信获取昵称或让顾问填写）
  weixin_openid: String, // 微信openid（用于唯一标识微信用户）
  phone: String,     // 手机号（如需要联系，可存储）
  ... // 其他登录信息：如 unionid、头像、token 等
}
说明：顾问通过微信登录后，若用户不存在则创建用户记录，赋予 role=consultant。所有云函数在操作数据时，可利用用户ID或openid确保只查询/修改属于该顾问的数据。
4. 云函数命名规范及功能定义
云函数统一部署在 uniCloud 云端，用于实现业务逻辑和数据库读写。命名规范采用“业务模块_动作”的形式，全部小写字母加下划线。例如：customer_create 表示创建客户的云函数。下面列出主要的云函数及其功能：
登录与用户：
login: 微信登录。接收前端微信登录凭证（code）和用户信息，调用微信API换取openid，检查数据库中用户是否存在，不存在则创建新User记录并初始化顾问资料。生成登录态（如JWT token）返回给前端。
blog.csdn.net
blog.csdn.net
门店 Store 模块：
store_list: 获取门店列表。返回当前顾问用户负责的所有门店信息列表（根据 consultant_id 过滤）。顾问进入“门店”页时调用。
store_update: 更新门店信息。允许顾问修改自己门店的基本资料。如名称、地址、电话等。参数包含门店ID和需更新字段。云函数会验证门店归属并执行更新。
（如果不允许顾问新增/删除门店，可暂不提供 store_create 和 store_delete。若需要，可类似实现，并限制顾问只能创建归属自己的门店。）
客户 Customer 模块:
customer_list: 获取客户列表。查询当前顾问的所有客户，支持根据筛选条件过滤。例如参数可包含 store_id（按门店过滤）、vip（是否VIP）、active（是否活跃）等，由后端根据条件筛选返回。结果按姓名或最近到店时间排序。
customer_get: 获取客户详情。（可选）根据客户ID获取完整信息，用于进入客户详情页时拉取最新数据（包括客户基本信息、以及后述各子项汇总）。如果在进入详情页时分别调用各子列表云函数，也可不单独提供此接口。
customer_create: 新增客户。将接收到的客户信息写入数据库新纪录，设置其 consultant_id/store_id 为当前用户，返回成功状态和新客户ID。需验证手机号等关键信息格式，避免重复客户（可根据电话检查）。
customer_update: 修改客户信息。更新指定客户记录的字段（姓名、电话等）。需验证当前用户是否有权限（只能修改自己的客户），然后执行更新操作。
customer_delete: 删除/注销客户。将指定客户标记删除（软删标记，如设置 status=deleted，或真删）。实际业务中，一般不物理删除以免丢失消费记录，可采用状态字段控制。在删除前应检查该客户是否还有未完成的预约或剩余套餐，如有则提示无法删除。
套餐 Package 模块:
package_list: 获取套餐列表。根据客户ID返回该客户所有购买的套餐记录列表，包含每个套餐的剩余次数等信息。用于客户详情页“购买”tab 列表展示。参数应包含 customer_id，后端在其用户下查询 Package 表。
package_create: 新增套餐购买。为指定客户添加一条套餐记录。参数包含 customer_id，以及套餐选择信息（如 product_id 或直接的名称、价格、总次数等）。云函数在数据库中新建记录，并返回记录ID。可在云函数中同步更新 Customer 表的累计消费（total_spent）等字段（例如 total_spent += price）。
blog.csdn.net
package_update: 更新套餐信息。允许修改套餐记录的某些字段，如调整剩余次数（例如顾问纠正错误消耗）、变更备注等。通常很少直接修改套餐除非管理后台，有需要可实现。也可用于标记套餐已结束等状态。
package_delete: 删除套餐（可选）。如要支持撤销某次购买，可实现此接口，将对应 Package 记录置为无效并可能退费处理。此属非常规操作，视业务决定。
消耗 Usage 模块:
usage_list: 获取消耗记录。按照客户ID查询其所有消耗记录，或根据套餐ID查询该套餐下的消耗记录。用于详情页“消耗”tab 列表。参数可以是 customer_id（优先）或 package_id，若提供 customer_id 则返回此客户所有Usage并按日期排序。
usage_create: 新增消耗记录。记录客户一次服务消耗。参数包含 customer_id、package_id、usage_date、amount 等。云函数将：
在 Usage 表插入新记录；
在 Package 表找到对应套餐，增加其 used_sessions，减少 remaining_sessions 等；
更新 Customer 表的累计消费次数（visit_count 加一）和最后到店时间（last_visit 更新为 usage_date）。
返回成功状态。如果套餐已无剩余次数也可在返回前提示（或由前端在列表中标识）。
usage_delete: 删除消耗记录（可选）。用于纠正错误记录。实现时需要反向恢复套餐剩余次数等数据。一般情况下谨慎提供删除，可不实现或仅管理员使用。
预约 Appointment 模块:
appointment_list: 获取预约列表。根据客户ID返回其预约记录列表，用于详情页“预约”tab。也可根据日期范围查询当前顾问在某段时间的所有预约（用于首页提醒或报表统计）。实现上可提供多种筛选模式，例如参数包含 customer_id（按客户查）或 dateRange（查某时间段所有预约）。
appointment_create: 新增预约。参数包含 customer_id、预约时间、服务项、门店等。云函数将新纪录写入 Appointment 表，设置状态为 "pending"（待服务）。可在云函数内检查预约时间冲突（同一客户或同门店同时间已有预约则返回错误）。成功则返回预约ID。
appointment_update: 更新预约。允许修改预约时间或状态等。如顾问完成服务后，可调用此接口将 status 置为 "completed"，也可修改预约时间或备注。权限上确保只能修改自己的客户预约。
appointment_cancel: 取消预约（可视为 appointment_update 的特例）。将预约状态改为 "cancelled"并记录取消时间。可通过统一的 update 接口实现，或单独实现以语义清晰。
报表/统计 Reports 模块:
stats_overview: 概览数据获取。为首页或报表页提供概要统计。如返回当前顾问的总客户数、总销售额、进行中的预约数量等汇总值。前端首页加载时调用此云函数获取数据展示。
stats_by_month: 月度数据统计。用于报表页，按月份汇总一些指标（新增客户、总消费额等），返回数组用于绘制图表。参数可包含 year/yearMonth 等。
stats_by_store: 门店数据统计（如果需要区分门店）。返回各门店的业绩、客户数等对比，用于报表展示。
注：报表相关函数根据需求扩展，主要是读DB进行聚合计算并返回结果。命名上统一以stats_或report_前缀，加上具体维度名称。
命名规范：以上云函数命名使用下划线隔开实体和动作，名称清晰易懂。如需更RESTful风格，也可以用customer/create等云对象形式。不过普通云函数命名简单直观即可。同时，注意避免与uniCloud系统保留名称冲突，不同功能的函数名保持唯一，不要混淆。 公共模块：可在uniCloud的公共模块中创建共享代码，如数据库初始化、返回码定义等。例如创建common/utils.js封装通用校验方法、common/response.js封装统一的返回结构（如 { code: 0/1, msg: '', data: {} }）。
5. 页面交互流程
下面描述几个关键功能的前端交互流程和云端交互，确保开发时逻辑清晰顺畅：
“新增客户”流程：顾问在客户列表页点击「新增客户」按钮，流程如下：
进入表单页：跳转到pages/customers/edit，页面标题显示“新增客户”。表单初始为空白。
填写信息：顾问在各字段输入客户资料（姓名、电话等）。前端对关键字段进行简单验证（如手机号格式、姓名非空）。
提交保存：用户点“保存”按钮后，前端组装表单数据为一个对象，调用封装的云函数请求方法，例如：
call({ name: 'customer_create', data: formData })
  .then(res => { ... })
其中 call 为统一封装的请求方法，通过 uniCloud.callFunction 调用后端
blog.csdn.net
。请求过程中前端显示加载中提示uni.showLoading()，防止重复点击
blog.csdn.net
。
后端处理：customer_create 云函数收到请求数据，进行服务端验证（例如检查该手机号是否已存在
blog.csdn.net
），然后写入 Customer 表，关联上当前登录用户的ID。成功后返回新记录ID或完整信息。
前端处理结果：收到成功响应后，前端关闭loading
blog.csdn.net
。可以showToast提示“新增客户成功”，然后：
将新客户插入客户列表数据源并刷新列表显示；或者
导航回客户列表页，并在 onShow 中重新调用customer_list刷新。
本流程结束，顾问可在列表中看到刚添加的客户项。
“编辑客户”流程：与新增类似，区别在于进入编辑页时会携带客户ID参数，页面加载时调用customer_get获取现有数据填充表格。用户修改后提交，前端调用customer_update云函数，后端校验并更新数据库。返回成功后前端提示并返回详情页或列表页。列表页数据相应更新（本地更新或重新拉取）。
“客户详情查看 & 套餐/记录新增”流程：当顾问点击客户列表中的某客户项时：
进入详情页：导航到pages/customers/detail，加载时根据传入customer_id调用各数据接口获取该客户详情：包括基本信息（可由customer_get返回）以及套餐、消耗、预约列表（分别调用package_list、usage_list、appointment_list）。采用并行请求提高效率，也可在后端提供一个汇总接口一次返回。【若网络较慢，也可在进入详情前已在列表接口返回部分数据，以减少请求】
切换Tab：详情页初始默认显示“购买”Tab，下方列出套餐列表。顾问可左右滑动切换到“消耗”或“预约”Tab，相应列表组件会根据已有数据渲染。如数据未预先加载，可在切换时懒加载调用对应云函数获取。
新增操作：无论当前在哪个Tab，顾问点击底部“+”按钮都会跳转相应的新增页（如点“+预约”则跳转预约新增页)。新增流程如下：
以“新增预约”为例：页面打开时自动带入当前客户ID（因此表单可锁定客户姓名显示），顾问选择日期时间等信息后提交。前端调用appointment_create云函数；后端写库成功返回。前端随后自动返回客户详情页，并在返回时通过appointment_list刷新预约列表（或本地在列表末追加新预约）。预约Tab下即可看到新记录。
“新增购买套餐”流程：从详情页点击“+购买”按钮 -> 进入套餐新增页。顾问选择套餐类型（从产品列表）和填写购买细节 -> 提交调用package_create -> 返回详情页后刷新“购买”列表，新增套餐出现在列表顶，并更新客户累计消费。
“新增消耗”流程：点击“+消耗” -> 进入消耗新增页。顾问选定是哪项套餐下消耗一次 -> 填写消耗日期等 -> 提交usage_create -> 返回详情页刷新“消耗”列表。同时由于消耗会更新套餐剩余次数，前端应同步更新“购买”列表中该套餐的信息（可重新获取package_list或在已有数据上调整剩余次数）。也可更新客户的最后到店时间和到店次数显示。
“删除/归档客户”流程（如提供）：顾问在客户详情或编辑页选择删除该客户：
前端弹确认框提示“确认删除？此操作将不可恢复且相关记录将保留归档。”避免误操作。
用户确认后调用customer_delete云函数，后端将客户标记删除（而非物理删除，status置为deleted等），并返回成功。
前端从当前列表中移除该客户并showToast提示“客户已删除”。若在详情页执行删除则返回列表页。注意同时可能需要处理该客户相关的套餐、预约数据不再展示（可由查询语句自然过滤掉已删除客户的数据）。
“登录流程”（首次使用小程序）：
小程序启动时，如未登录，则调用微信API进行登录授权。使用wx.login获取 code，再调用wx.getUserProfile获取昵称头像等用户信息
blog.csdn.net
。
拿到临时登录凭证 code 以及用户信息后，前端调用uniCloud.callFunction({ name: 'login', data: { code, ...userInfo } }) 发送至云端登录函数。
云函数中使用 code 调用微信开放接口获取 openid，与数据库用户表比对；首次登录则创建新用户记录并赋予顾问角色。然后生成登录 token 返回给前端。
前端收到响应，保存 token（例如使用 uni.setStorageSync('token', token)）以及用户基本信息到本地。
blog.csdn.net
blog.csdn.net
后续请求会自动携带 token（通过云函数调用封装实现）。然后跳转进入首页。
此后每次打开小程序，若本地有 token 且未过期，可直接进入应用（可调用 uniCloud.callFunction 测试 token 有效性，否则重新走授权）。这样顾问免除频繁登录。
各页面的其它细节交互如列表下拉刷新（Pull-to-refresh 调用列表接口刷新数据）、上拉加载更多（如客户列表分页显示，滑动到底触发加载下一页数据）等，也应实现以优化体验。
6. 前端调用云函数统一方式（call.js）
为简化前端每次调用 uniCloud.callFunction 的重复代码和统一处理错误，项目中封装一个通用模块（例如 utils/call.js）提供统一的云函数请求方法。这样可以集中管理请求过程，如自动添加鉴权信息、统一错误提示等
blog.csdn.net
。实现思路如下：
封装call函数：在 call.js 中定义一个函数，如 function call(option)，内部使用 uniCloud.callFunction 发起云函数调用
blog.csdn.net
。
option 参数包含：name（云函数名）、data（传递的数据对象）、success/fail 回调等。也可以仅返回 Promise。
函数内部会先读取本地存储的 token（uni.getStorageSync('token')）
blog.csdn.net
。如果 token 存在，将其附加到 option.data.token 或请求头中，这样后台云函数可以验证身份。
调用前，触发 loading 提示，如 uni.showLoading({ mask: true }) 显示全局加载框
blog.csdn.net
。调用完成后（不论成功失败）在 .finally 中 uni.hideLoading()
blog.csdn.net
, 确保界面反馈及时。
通过 Promise 封装，使得用法可以是：
call({ name: 'customer_list', data: {} })
  .then(data => { /* 成功，data为res.result.data */ })
  .catch(err => { /* 失败处理 */ });
也可以支持回调风格以兼容不同用法。
若后端返回约定的错误码，例如未登录或token失效（假设 code = 401 或自定义 203），封装函数内可统一处理：如弹出“请登录”提示并自动导航到登录页
blog.csdn.net
。这样各页面无需重复判断登录失效情况
blog.csdn.net
。
对于业务错误（如云函数返回 code 非200的错误信息），封装函数可以直接用 uni.showToast 提示 res.result.msg
blog.csdn.net
。只有真正的成功结果才resolve，让调用页面拿到有效数据。
封装模块最后 module.exports = { call }，以便引入。也可以将其封装为 Vue 全局变量或通过插件注入 (如 app.config.globalProperties.$call = call)，这样页面中直接使用 this.$call(...) 调用更方便。
使用call.js：在需要调用云函数的地方，引入并使用封装的 call 方法。例如在客户列表页面的 onLoad 或 onShow 中：
import { call } from '@/utils/call.js';
// ...
async fetchCustomers() {
  try {
    const data = await call({ name: 'customer_list', data: {} });
    this.customers = data.customers; // 假设后端返回 { customers: [...] }
  } catch(e) {
    console.error('加载客户列表失败', e);
  }
}
因为封装做了自动 loading 提示和错误处理，页面代码中无需每次处理 loading 和token。
注意：封装函数内通过 uniCloud.callFunction 调用云函数时，必须正确填写云函数名称option.name和数据option.data。uniCloud会自动根据 name 找到对应云函数执行。
关于Token传递：上面方案中，将 token 存储于本地并每次请求附带
blog.csdn.net
。另一种方案是使用uni-id提供的钩子自动校验，无需手动传 token（uniCloud.callFunction 会自动携带登录态），但本方案清晰地展示了token机制，可控性更高。为了安全，token应有有效期，后台返回 code=203/401表示失效时，前端在 call.js 里检测到后及时引导用户重新登录
blog.csdn.net
。这样保证云函数受到保护，数据不泄露。
统一返回结构：建议所有云函数返回统一的结构，例如：
{ code: 0, msg: 'success', data: {...} }
或
{ code: 200, data: {...}, token: '...' }
等等。在 call.js 中根据 code判断成功或不同错误
blog.csdn.net
。如 code == 200 视为成功，code == 201 业务错误（如参数校验未通过）则提示 msg
blog.csdn.net
；code == 203 登录失效则处理跳转登录
blog.csdn.net
；其他 code 作为异常。统一的封装让代码维护更规范。
通过 call.js 统一管理云函数调用，能大大减少重复代码，提高可靠性
blog.csdn.net
。日后如果调整后端返回格式或增加全局错误处理，只需修改这一处封装即可，全局生效。
7. 权限控制约定
鉴于本小程序仅面向“美容顾问”这一种角色用户，权限控制主要体现为数据隔离和云端校验，确保顾问只能访问管理自己的数据。约定如下：
单一角色：所有登录用户均为顾问（Consultant）。系统没有管理员或店长等其他角色。因此应用界面和功能不涉及角色切换逻辑。只需要在登录时识别用户身份，将其绑定相应门店和客户即可。
身份验证：用户必须通过微信授权登录获取token后才能访问应用功能。未登录或token过期时，云函数一律返回未授权错误，前端拦截并引导重新登录
blog.csdn.net
。在 uniCloud 上可以通过 context.OPENID 或使用 uni-id 校验token 来识别请求用户。所有敏感数据的云函数必须在服务端验证用户身份有效。
数据隔离：数据库设计上，每个数据表记录都关联所属顾问的标识：
Customer、Store、Package、Appointment 等表都有字段指明所属顾问用户（如 consultant_id 或通过关联 store->consultant，再customer->store间接关联）。云函数查询时必须使用当前登录用户ID作为条件筛选，防止越权读取他人数据。比如：db.collection('Customer').where({ consultant_id: currUserId })。
在没有多角色的简化场景，可直接用 openid 作为顾问标识存储在这些记录中，然后用 context.OPENID 匹配。【但使用uni-id体系有更完善的用户ID】
云函数权限校验：每个业务云函数内部都会进行权限检查：
登录校验：一般可利用 uniCloud 的云函数模块参数 context 提供的 auth 信息，确定用户已登录且合法。例如 uni-id 校验 token 后会在 context.identity 提供 uid。没有登录则立即返回错误，不继续处理。
数据归属校验：对于涉及特定记录的操作（如更新或删除某个客户、添加某个门店的数据），函数需校验该记录确实属于当前用户。例如 customer_update(customerId) 时，先查询此Customer的 consultant_id是否等于当前用户UID，不匹配则返回权限错误。
操作限制：顾问角色在前端仅看到属于自己的数据，但仍需在云端 enforce。例如即使前端不显示别人的客户ID，一个恶意用户通过改请求参数ID也无法操作不属于他的客户记录，因为后端检查会阻止。
存储安全：用户上传的任何私人数据（如果有照片等）也应带有用户标识，并存储在私有权限的云存储空间或数据库相应集合中。不开放公共读取权限。
前端展示限制：由于只有顾问角色，不存在功能模块对不同角色的隐藏问题。但仍需考虑部分顾问可能负责多个门店的情况。前端应防止顾问查看未分配给自己的门店内容。例如如果顾问A尝试通过修改页面参数去访问顾问B的门店ID详情页，因为后端有隔离，他拿不到数据，前端应处理这种“无权限或无数据”返回的情况（提示“无法访问”）。
uni-id 一体化（可选）：如采用uni-id插件，可方便利用内置的用户角色管理。在uni-id创建用户时可赋予role数组包含"consultant"标识。随后可以在云函数的 uniID.checkToken() 返回结果里校验该用户角色。如果要预防非顾问角色调用接口，可加一层判断，如：
const payload = await uniID.checkToken(token);
if (payload.code !== 0 || !payload.roles.includes('consultant')) {
  return { code: 403, msg: '无权访问' };
}
但本项目默认只有顾问注册用户，因此这个判断可选。
总之，权限控制原则是：顾问只能看见和修改自己负责的门店及客户的数据。无论前端如何调用，后台都会严格按照用户ID过滤数据
developer.apple.com
。这样即使未来扩展了其他角色，当前的数据模型也确保了安全性和私密性。
8. UI 细节规范
界面设计遵循 Apple 风格，强调简洁、美观、易读。以下从颜色、排版、控件等方面制定具体规范，以确保UI的一致性和高品质：
整体配色（浅色调）：界面以浅色系为主，背景多用白色或淡灰色。大面积留白营造清爽感
zcool.com.cn
。避免使用过多色彩，建议全站不超过3种主色
zcool.com.cn
。
主题色：选用柔和且有品质感的颜色作为强调色。例如截图中的金色（如浅金 #C8AB79）用于高亮重要元素（选中的Tab标签、VIP标识、主要按钮）以体现高端美容行业气质。主题色应用于Tab选中状态、主要按钮背景等，不宜大面积实底，以免喧宾夺主。
文本色：主要文字使用深灰或黑色（#333 或 #000），确保对比度和可读性。次要文字（说明、备注、时间等）使用次级灰色（#666/#999）。禁用或占位文字用更淡的灰色（#CCC）。整体文字颜色层级分明：重要信息偏深色，次要信息浅色区分
blog.csdn.net
。
背景色：页面背景使用极浅的灰白色调（如#F5F5F7，接近苹果默认分组表视图背景），模块/卡片内部背景为纯白色，形成卡片与背景的轻微区分。必要时可使用非常浅的阴影或1px细线作为卡片边框底色，以突出卡片而不突兀。
反馈色：正确或积极操作可使用主题色系深一点表示（或绿色），错误警示使用苹果红色(#FF3B30)提示，但使用频率应低。整体色彩均保持低饱和度和明度适中，符合Apple清新风格。
字体与字号：采用系统默认字体（苹果设备上为 San Francisco/苹方，其他平台为各自系统字体），保证清晰易读
m.zcool.com.cn
。字号遵循层级：
页面标题：18px-20px，加粗（600-700权重）。如“客户管理”“客户详情”标题，突出页面层次。
内容正文：14px-16px，常规(400)或中等(500)权重。多数列表文字、表单标签等使用14px，确保在小程序上清晰可读。
次要文字：12px-14px，用于辅文说明、标签等。例如列表中“上次到店：2天前”可以是12px，颜色偏次级灰#999。
数字强调：对于关键指标数字，可适当加大字号或加粗。如首页汇总的大数采用18px粗体，旁边单位/标签12px细体，从视觉上形成主次对比。
行高：正文内容建议行高约1.5倍字号，保持足够留白。表单项标签和输入可以略紧凑些但不小于1.2倍字号，保证可读性和触摸空间。
字体风格：全局使用无衬线字体，尽量不使用倾斜、下划线等特殊样式。强调可通过颜色或粗细，不依赖非标准字体。
布局与留白：遵循“8pt网格”系统，所有间距使用8的倍数，营造良好呼吸感
blog.csdn.net
：
页面边距：左右边距统一为16px（两个8的基本倍数），顶部底部边距也至少8或16px，保证内容不贴边。
模块间距：大块区域之间留白32px或24px，上下分隔明显。卡片之间垂直间距可用16px。列表项之间一般8px间隔（如果列表项有分割线也可不留太大空隙）。
blog.csdn.net
组内间距：如卡片内的标题与内容间距8px，图标与文字间距4px等，小尺度采用4px增量微调。表单各字段之间上下间距16px，字段内label与控件之间水平方向8px左右。
行内元素：按钮、图标与文字组合时，周围也留有足够间隔，不显局促。例如按钮内文字左右各留12px内边距，图标和文字距离4-6px。
留白运用：大量留白是苹果风格要点之一，用空白替代繁复的线条进行分组
zcool.com.cn
。例如客户列表中，列表项之间不一定画实线分隔，而通过8-12px的垂直留白和背景色区分，使界面更为通透。
圆角规范：界面元素广泛采用圆角矩形，使视觉友好柔和
zhuanlan.zhihu.com
。
卡片和模块：圆角半径统一约 8px，应用于主要卡片容器（列表项背景、弹出框、按钮）。8px圆角在移动端比较常见，既体现设计感又不会过于圆润。
小型元素：如标签、图标按钮等，可使用 4px 圆角，甚至pill形（全圆角），根据元素高度调整。例如“VIP”小标签高度大约16px，可用4px圆角；筛选栏的segmented控制高度约30px，可用15px圆角变成胶囊形。
对话框/弹窗：顶部圆角可以更明显（如10-12px）以示与直角屏幕边缘区分。
一致性：所有可点击按钮、输入框、卡片都应遵循以上圆角值，保持统一的视觉规则，避免有的元素圆角过大或过小不协调。
blog.csdn.net
图标与图形：采用简洁线性图标，风格统一，大小适中：
底部TabBar图标可使用官方推荐尺寸（约24px），采用线性icon或扁平icon，风格与iOS系统图标相近（如简洁的线条和几何图形）。选中状态可填充主题色，不选中灰色。TabBar下方配文字标签，字体10px-11px，选中时同主题色。
页面内的小图标（例如搜索框的放大镜、列表项右侧的箭头、电话图标等）建议使用outline风格的图标库，线条粗细适中（大约2px线宽）。颜色一般为中性灰(#999)以不喧宾夺主。
操作按钮使用的+号图标、编辑图标等，也使用统一图标库风格。加号建议为圆形背景按钮内一个粗线加号，体现亲和力。
推荐图标库：可以采用 Iconfont 上的苹果风格图标，或者使用 FontAwesome的细线版Icons，通过 uni-app 的 <uni-icons> 组件或自定义Icon组件引用。本项目可选用 @vicons/fa等Icon库
ext.dcloud.net.cn
, 例如 import { User, Home, Shop } from '@vicons/ionicons5' 等，然后通过 <Icon>组件渲染以确保清晰。
图标尺寸：一般小图标16px或20px，放在文本旁确保对齐居中。大一点的操作按钮图标可到24px。注意在高清屏上使用2倍图或SVG，避免模糊。
按钮和可点击元素：
主按钮：如保存、确认类操作按钮，采用填充主题色背景，白色文字，圆角矩形（radius 6-8px）。高度约40-44px，左右内边距16px以上。确保按钮有足够触摸面积。按下时背景色变深一点点，提供触感反馈。
次按钮：次要操作或取消按钮，采用浅色背景或线框样式。比如“取消”按钮白底+灰色边框+圆角，文字灰黑色。保持风格简洁，不用过多阴影渐变。
列表项：整个卡片区域都可点进详情的列表项，需要有点按反馈（如轻微背景色变化或Material波纹效果）。实现可用 CSS :active 改变背景为浅灰，或uni-app内置的active-class实现。
图标按钮：如右上角的“新增”"+"、编辑"✏️"图标等，一般透明背景，仅图标变色反馈或加涟漪。大小触摸区至少40px。
禁用态：按钮不可用时背景变淡、文字灰色，并禁用点击。比如提交按钮在表单未填完整时处于禁用浅灰状态。
Tab/segmented控件：筛选Tab和详情页内部Tab，都属于切换控件，选中和未选中状态颜色对比明显。选中背景或下划线用主题色，未选中文本灰色黑色。切换有动画过渡更佳，提升品质。
输入和表单：
输入框：圆角边框矩形，高度约40px，左右内间距12px。边框颜色浅灰(#DDD)，获得焦点时边框或阴影高亮（主题色或更深灰）。也可无边框、底部细线风格，看设计取舍。苹果风格偏好无边框浅底：比如背景浅灰的圆角矩形，无明显边框线，内有提示文字。可参考iOS的搜索框样式。
标签和占位：表单前的标签文本用14px右对齐，或者干脆采用浮动提示形式。占位符字体12px灰色，输入后消失或上浮。
选择器：性别、日期等采用系统选择控件弹窗，样式遵循系统(避免自定义破坏一致性)。如果自定义，也使用iOS风格的滚轮或弹出面板圆角设计。
开关：如VIP开关，可使用uni-ui的 <uni-switch>，iOS风格的圆形滑块，选中时绿色或主题色。
反馈和提示：
Toast：使用uni.showToast，样式用默认或轻量样式，文字简洁居中展示。不要持续太久，一般2秒消失。
Modal：确认删除等对话框使用微信提供的 showModal 或自定义弹窗，遵循系统样式（iOS弹窗圆角矩形，标题17px粗体，消息内容14px，按钮蓝色正常/红色警示）。
Loading：全局loading用 uni.showLoading({mask:true}) 实现，全屏半透明遮罩+菊花圈，文案“加载中…”。尽量短时出现，数据加载如能秒级完成则可以无文案或者用骨架屏。提交时用loading防多击，完成即关闭。
空态：列表无数据时，提供空状态视图。如一个淡淡的灰色图标（用户/档案图标）+ “暂无客户”短语，提示用户当前无记录。风格简洁有亲和力。空态图标可用线性插画或简洁图形，尺寸80px左右，搭配浅灰文字12px。
错误页/网络异常：若网络错误，采用统一的错误提示页，用简单图标+文字，让用户尝试重新加载。
Apple风格特征总结：保持 简洁（去除不必要元素
zcool.com.cn
）、一致（整体设计语言统一）、层次（用留白和字体权重建立层次
blog.csdn.net
）、对齐（元素对齐整齐）和细节（动画流畅、触感反馈及时）。从配色到字体到控件，都尽量贴近iOS原生的感觉，让用户感到熟悉和舒适
zcool.com.cn
。大量留白令界面更高级，干净的背景减少干扰
zcool.com.cn
。通过以上规范，我们确保小程序的UI既有苹果风的高雅，又符合美容行业的清新专业形象。
以上即为顾问端小程序的结构化开发文档。通过明确的页面划分、组件设计、数据和接口规范以及UI标准，开发者可以据此高效实现功能并保证一致的用户体验。本方案充分考虑了美容行业业务特点和Apple设计美学，可作为开发过程中的基准指导。